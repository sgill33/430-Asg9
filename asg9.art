;TYPEDEFS
define :oneArg [ 
    tag                 
    val
][ 
    init: [
        this\tag: this\tag
        this\val:  this\val
    ]
    compare: 'val
]

define :Binding [ 
    name                 
    val
][ 
    init: [
        this\name: this\name
        this\val:  this\val
    ]
] 

addP: function[a b][
    a + b
]
subP: function[a b][
    a - b
]
multP: function[a b][
    a * b
]
divP: function[a b][
    if? b = 0 -> print "Error cannot divide by zero"
    else -> a / b
]
leqP: function [a b][
    a =< b
]
eqP: function [a b][
    a = b
]

truPrim: to :Binding["true" true]
falsPrim: to :Binding ["false" false]
; addPrim: to :Binding["+" addP]
; subPrim: to :Binding["-" subP]
; multPrim: to :Binding["*" multP]
; divPrim: to :Binding["/" divP]
; leqPrim: to :Biding["<=" leqP]
; eqPrim: to :Binding["=" eqP]

topenv: [truPrim falsPrim
; addPrim
; subPrim
; multPrim
; divPrim
; leqPrim
; eqPrim
]

define :ifC [
    test
    then
    else
] [ 
    init: [
        this\test: this\test
        this\then: this\then
        this\else: this\else
    ]
]

define :lamC [
    params
    body
] [ 
    init: [
        this\params: this\params
        this\body: this\body
    ]
]

define :appC [
    fun
    args
] [ 
    init: [
        this\fun: this\fun
        this\args: this\args
    ]
]

;FUNCTION DEFS

lookup: function[for env][
    loop env 'binding [
        if? binding\name = for -> return binding\val
    ]
    print "lookup error: name not found"
]

; Interpreter for OAZO5 language, evaluates an ExprC and Env
; into a Value
interp: function[exp env][
    case [exp]
        when?[type exp = :oneArg] [if? or? exp\tag = "str" exp\tag = "num" -> return exp\val
        else -> return lookup exp\val env]
        when?[type exp = :ifC]  [if? interp exp\test -> return interp test
        else -> return interp else]
        when?[is? :lamC exp] -> return exp\body
        when?[is? :appC exp] -> return exp\fun
        else -> [print "Error"]
]

num1: to :oneArg ["num" 1]
num2: to :oneArg ["num" 2]
str1: to :oneArg ["str" "hello"]
id1: to :oneArg ["id" "true"]
if1: to :oneArg ["true" num1 num2]

print interp num1 topenv
print interp str1 topenv
print interp id1 topenv

;TESTCASES

; if? interp num1 = 34 [print "Test 1 Passed: " interp num1]
; else [print "Test 1 Failed:" interp num1]

; if? interp str1 = "hello" [print "Test 2 Passed: " interp str1]
; else [print "Test 2 Failed:" interp num1]
